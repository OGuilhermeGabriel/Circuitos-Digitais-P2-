# Lista de Projeto 01 - Circuitos Digitais
Projeto direcionado √† disciplina de Circuitos Digitais, ministrada pelo Prof Dr Pedro Thiago Val√©rio de Souza no per√≠odo 2024.1, na Universidade Federal Rural do Semi-√Årido (UFERSA).

# Autores 
- Caio Barreto Meyer | [Caio B. Meyer](https://github.com/TaiCaio) 
- Guilherme Gabriel Saldanha Pereira | [OGuilhermeGabriel](https://github.com/OGuilhermeGabriel)

# Sum√°rio 
- [Problema 01](#problema-01)
- [Problema 02](#problema-02)
- [Problema 03](#problema-03)
- [Problema 04](#problema-04)
- [Problema 05](#problema-05)
- [Problema 06](#problema-06)
- [Problema 07](#problema-07)
- [Problema 08](#problema-08)
- [Problema 09](#problema-09)
- [Problema 10](#problema-10)
- [Problema 11](#problema-11)
- [Problema 12](#problema-12)
- [Refer√™ncias](#refer√™ncias)

# Lista de Projetos 
Implemente os seguintes circuitos em SystemVerilog utilizando a abordagem designada:

# Problema 01
Um circuito gerador de paridade √≠mpar de um n√∫mero de 8 bits utilizando fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o
Um gerador de paridade √≠mpar pode ser representado por um circuito composto por 8 entradas (para 8 bits) associados por XNOR's de forma cascata. Nesse sentido, a sa√≠da ir√° gerar um √∫nico bit: Caso a sequ√™ncia de valores dos 8 bits tenha uma quantidade de 1's par, o bit de paridade gerado ir√° ter o valor 1. Caso a sequ√™ncia de valores dos 8 bits tenha uma quantidade de 1's √≠mpar, o bit de paridade gerado ir√° ter o valor 0.

Como o problema pede para ser resolvido por fluxo de dados, a descri√ß√£o do circuito foi feita em termos das suas pr√≥prias express√µes l√≥gicas, relacionando as entradas do gerador com a sa√≠da do mesmo. 

## Descri√ß√£o em *systemverilog* 
~~~
module paridade(
    //descrevendo os 8 bits de entrada do gerador
    input logic b7, b6, b5, b4, b3, b2, b1, b0,
    //descrevendo o bit de sa√≠da do gerador
    output logic paridade
);
    //express√£o de sa√≠da do gerador de paridade √≠mpar
    assign paridade = ~(b7 ^ b6 ^ b5 ^ b4 ^ b3 ^ b2 ^ b1 ^ b0);
endmodule
~~~

# Problema 02
Um decodificador para display de sete segmentos √¢nodo comum, que seja capaz de representar os d√≠gitos em hexadecimal. Utilize a abordagem comportamental e estrutura case.

## Resolu√ß√£o

A primeira coisa a se fazer para projetar este decodificador √©, especificamente, determinar como ser√£o os segmentos quando eles estiverem ligados. 

A imagem abaixo mostra o modelo adotado para representar os d√≠gitos em hexadecimal.

![P2_Display](/Problema%2002/Problema%2002%20-%20Assets/segmentos.png)

Em seguida, faz-se necess√°rio fazer a tabela verdade, para relacionar cada d√≠gito hexadecimal (formada por 4 bits) com a sequ√™ncia de segmentos ligados e desligados que formam o d√≠gito visualmente. 

- TABELA VERDADE

 *b3* | *b2* | *b1* | *b0* |*a*|*b*|*c*|*d*|*e*|*f*|*g*| 
 -----| -----| -----| -----| --| --| --| --| --| --| --|  
  0   |  0   |  0   |  0   | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
  0   |  0   |  0   |  1   | 1 | 0 | 0 | 1 | 1 | 1 | 1 |
  0   |  0   |  1   |  0   | 0 | 0 | 1 | 0 | 0 | 1 | 0 |
  0   |  0   |  1   |  1   | 0 | 0 | 0 | 0 | 1 | 1 | 0 |
  0   |  1   |  0   |  0   | 1 | 0 | 0 | 1 | 1 | 0 | 0 |
  0   |  1   |  0   |  1   | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
  0   |  1   |  1   |  0   | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
  0   |  1   |  1   |  1   | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
  1   |  0   |  0   |  0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
  1   |  0   |  0   |  1   | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
  1   |  0   |  1   |  0   | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
  1   |  0   |  1   |  1   | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
  1   |  1   |  0   |  0   | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
  1   |  1   |  0   |  1   | 1 | 0 | 0 | 0 | 0 | 1 | 0 |
  1   |  1   |  1   |  0   | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
  1   |  1   |  1   |  1   | 0 | 1 | 1 | 1 | 0 | 0 | 0 |

## Descri√ß√£o em *systemverilog*

~~~
module display(
    //definindo a sequ√™ncia de bits que definir√° o segmento
    input logic [3:0] digito,
    //definindo os 7 segmentos do display
    output logic [6:0] segmento 
);
    //aplicando um always_combinacional p/ o bloco condicional
    always_comb begin 
        case(digito)
            4'h0 : segmento = 7'b0000001; //segmento para o digito hex 0
            4'h1 : segmento = 7'b1001111; //segmento para o digito hex 1
            4'h2 : segmento = 7'b0010010; //segmento para o digito hex 2
            4'h3 : segmento = 7'b0000110; //segmento para o digito hex 3
            4'h4 : segmento = 7'b1001100; //segmento para o digito hex 4
            4'h5 : segmento = 7'b0100100; //segmento para o digito hex 5
            4'h6 : segmento = 7'b0100000; //segmento para o digito hex 6
            4'h7 : segmento = 7'b0001111; //segmento para o digito hex 7
            4'h8 : segmento = 7'b0000000; //segmento para o digito hex 8
            4'h9 : segmento = 7'b0000100; //segmento para o digito hex 9
            4'hA : segmento = 7'b0001000; //segmento para o digito hex A
            4'hB : segmento = 7'b1100000; //segmento para o digito hex B
            4'hC : segmento = 7'b0110001; //segmento para o digito hex C
            4'hD : segmento = 7'b1000010; //segmento para o digito hex D
            4'hE : segmento = 7'b0110000; //segmento para o digito hex E
            4'hF : segmento = 7'b0111000; //segmento para o digito hex F
            default : segmento = 7'b1111111; // segmento para condi√ß√µes imposs√≠veis
        endcase
    end
endmodule 
~~~

Utilizando a abordagem comportamental, onde o circuito deve ser descrito em termos do seu comportamento algor√≠tmico, foi implementada ent√£o a estrutura *case* dentro do procedimento *always_comb*, sendo um procedimento *always* utilizado para mapear circuitos l√≥gicos combinacionais, como este circuito o qual descreve o display. 

Al√©m disso, vale mencionar a importancia da implementa√ß√£o da estrutura *case*, a qual descreve as condi√ß√µes de cada dig√≠to hexadecimal para cada sequ√™ncia dos 7 segmentos de forma r√°pida e pr√°tica. Vale salientar ainda que, em termos de projeto, a escolha "*default*" foi atribuida para quando nenhum dos d√≠gitos hexadecimais registrados seja selecionado, onde no display, nenhum segmento ser√° aceso. 

# Problema 03
Um decodificador 3x8 com entrada de habilita√ß√£o utilizando fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o

Um decodificador 3x8 √© um bloco l√≥gico combinacional definido por 3 entradas e 8 sa√≠das, onde para cada combina√ß√£o das entradas, uma √∫nica sa√≠da ser√° ativada. Dessa forma, a tabela verdade pode ser representada dessa forma:
 
- TABELA VERDADE

 *b2* | *b1* | *b0* |*e7*|*e6*|*e5*|*e4*|*e3*|*e2*|*e1*|*e0*| 
 -----| -----| -----| -- | -- | -- | -- | -- | -- | -- | -- |  
  0   |  0   |  0   | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 1  |
  0   |  0   |  1   | 0  | 0  | 0  | 0  | 0  | 0  | 1  | 0  |
  0   |  1   |  0   | 0  | 0  | 0  | 0  | 0  | 1  | 0  | 0  |
  0   |  1   |  1   | 0  | 0  | 0  | 0  | 1  | 0  | 0  | 0  |
  1   |  0   |  0   | 0  | 0  | 0  | 1  | 0  | 0  | 0  | 0  |
  1   |  0   |  1   | 0  | 0  | 1  | 0  | 0  | 0  | 0  | 0  |
  1   |  1   |  0   | 0  | 1  | 0  | 0  | 0  | 0  | 0  | 0  |
  1   |  1   |  1   | 1  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |

## Descri√ß√£o em *systemverilog*

~~~
module decodificador(
    //colocando as entradas do decodificador 
    input logic b0,b1,b2, //b2 = X, b1 = Y, b0 = Z
    //colocando as sa√≠das do decodificador
    output logic e0, e1, e2, e3, e4, e5, e6, e7
);
    // atribuindo as express√µes para cada sa√≠da do decodificador (as 8)
    assign e0 = ((~b2)&(~b1)&(~b0));
    assign e1 = ((~b2)&(~b1)&(b0));
    assign e2 = ((~b2)&(b1)&(~b0));
    assign e3 = ((~b2)&(b1)&(b0));
    assign e4 = ((b2)&(~b1)&(~b0));
    assign e5 = ((b2)&(~b1)&(b0));
    assign e6 = ((b2)&(b1)&(~b0));
    assign e7 = ((b2)&(b1)&(b0));
endmodule 
~~~

# Problema 04
Um multiplexador 4x1 utilizando fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o
O mux 4x1 √© um bloco l√≥gico combinacional contendo quatro entradas e uma √∫nica sa√≠da, onde as entradas s√£o selecionadas a partir dos bits de sele√ß√£o que comp√µe a chave seletora. Dessa forma, como o que determina as combina√ß√µes das entradas s√£o os bits de sele√ß√£o, faz-se necess√°rio criar uma tabela verdade relacionando os bits da chave seletora com a sa√≠da do mux. 

- TABELA VERDADE 

 *s1* | *s0* |  *f* |
  --  |  --  | ---  |
   0  |   0  | *i0* |
   0  |   1  | *i1* |
   1  |   0  | *i2* |
   1  |   1  | *i3* |

Como tratasse de uma abordagem por fluxo de dados e operadores l√≥gicos, faz-se necess√°rio encontrar a express√£o que define a sa√≠da do mux. Uma vez que o multiplexador pode ser projetado com portas l√≥gicas como mostra a figura a baixo, √© poss√≠vel encontrar a express√£o l√≥gica para a sa√≠da *f*.

![P4_mux_logic](/Problema%2004/Problema%2004%20-%20Assets/mux_logic.jpg)

## Descri√ß√£o em *systemverilog*
~~~
module mux(
    //declarando as entradas 
    input logic i0, i1, i2, i3,
    //declarando a chave seletora (que s√£o entradas tamb√©m)
    input logic s0, s1,
    //declarando a sa√≠da
    output logic f
);
    //atribuindo a express√£o l√≥gica para a sa√≠da do mux 4x1
    assign f = (i0&(~s1)&(~s0)) | (i1&(~s1)&s0) | (i2&s1&(~s0)) | (i3&s1&s0);
endmodule
~~~

# Problema 05
Um multiplexador 4x1 de 8 bits utilizando abordagem comportamental e estrutura case.

## Resolu√ß√£o
O mesmo bloco combinacional ser√° descrito, s√≥ que desta vez, ser√° feito por meio de outra abordagem.

Ao inv√©s do circuito ser descrito em termos de suas express√µes de sa√≠da, ele ser√° descrito baseado no seu comportamento algor√≠tmico, utilizando a estrutura "*case*" por meio dentro de um procedimento "*always*".

## Descri√ß√£o em *systemverilog*

~~~
module mux2 (
    //declarando as 4 entradas 
    input logic [3:0] i,
    //declarando os 2 bits seletores 
    input logic [1:0] s,
    //declarando a sa√≠da 
    output logic f 
);
    always_comb begin
        case (s)
            2'b00 : f = i[0]; 
            2'b01 : f = i[1];
            2'b10 : f = i[2];
            2'b11 : f = i[3];
            //valor padr√£o caso a combina√ß√£o de bits de sele√ß√£o d√™ algo imposs√≠vel
            default: f = 1'b0; // sa√≠da = 0 
        endcase 
    end
endmodule
~~~

Dessa vez, as entradas normais e entradas de sele√ß√£o foram concatenadas e, com o procedimento "*always_comb*", fora utilizada a estrutura condicional "*case*". Contudo, note que a l√≥gica por tr√°s da descri√ß√£o deste circuito combinacional ainda continua a mesma.

# Problema 06
Meio somador, utilizando abordagem por fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o
Tamb√©m conhecido como *half adder*, tratasse de um circuito que soma duas entradas e a sa√≠da retorna a soma das duas entradas al√©m do carry-out, bit necess√°rio caso a soma seja 1+1.

## Descri√ß√£o em *systemverilog*

~~~
module halfadder (
    //definindo as entradas do half-adder
    input logic a, b,
    //definindo as sa√≠das do half-adder
    output logic s, cout
);
    //definindo as express√µes das sa√≠das do meio-somador
    assign s = a ^ b;
    assign cout = a & b;                                                                

endmodule 
~~~

# Problema 07
Somador completo, utilizando abordagem por fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o
Tamb√©m conhecidos como *full-adder*, a √∫nica diferen√ßa entre os somadores completos para os meio-somadores √© a presen√ßa da entrada de carry-in no bloco l√≥gico.

## Descri√ß√£o em *systemverilog*
~~~
module fulladder(
    //declarando as entradas do full-adder
    input logic a,b,cin, 
    //declarando as sa√≠das do full-adder
    output logic s,cout
);
    //declarando as express√µes de sa√≠da do full-adder
    assign s = a ^ b ^ cin;
    assign cout = (a&b) | (a&cin) | (b&cin); 
endmodule
~~~

# Problema 08
Somador de 4 bits com entrada de carry in, utilizando um conjunto de somadores completos e abordagem hierarquica.

## Resolu√ß√£o
Para fazer o somador de 4 bits, ser√° necess√°rio primeiramente criar o m√≥dulo do somador completo para que, em seguida, seja poss√≠vel criar o arquivo do somador de 4 bits, onde ser√£o criadas 4 inst√¢ncias a partir deste m√≥dulo do *full-adder*. Dessa forma, por meio dos 4 blocos de *full-adders* criados, o *4 bits-adder* contar√° com entradas *a* e *b* e sa√≠da *s* de 4 bits, os quais conter√£o os valores das inst√¢ncias criadas a partir do m√≥dulo do *full-adder*.

## Descri√ß√£o em *systemverilog*

Primeiramente, ser√° necess√°rio descrever o m√≥dulo do somador completo

~~~
module fulladder (
    //declarando as entradas do full-adder 
    input logic a, b, cin,
    //declarando as sa√≠das do full-adder 
    output logic s, cout 
);
    //declarando as express√µes de sa√≠da do full-adder 
    assign s = a ^ b ^ cin; 
    assign cout = (a&b) | (a&cin) | (b&cin);
endmodule 
~~~

Em outro arquivo, o somador de 4 bits ser√° descrito

~~~
module quatrobitsadder (
    // declarando as entradas do somador de 4 bits 
    input logic [3:0] a, b,
    // declarando o carry-in do somador 
    input logic cin,
    // declarando a sa√≠da da soma em 4 bits
    output logic [3:0] s, 
    // declarando o carry-out do somador 
    output logic cout
);
    // declarando os sinais intermedi√°rios dos carrys
    // ~ s√£o os sinais de carry que est√£o ENTRE os blocos somadores 
    logic c1, c2, c3; 

    // inst√¢nciando os 4 full-adders 
    fulladder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .s(s[0]), .cout(c1));
    fulladder fa1 (.a(a[1]), .b(b[1]), .cin(c1), .s(s[1]), .cout(c2));
    fulladder fa2 (.a(a[2]), .b(b[2]), .cin(c2), .s(s[2]), .cout(c3));
    fulladder fa3 (.a(a[3]), .b(b[3]), .cin(c3), .s(s[3]), .cout(cout));

endmodule
~~~

# Problema 09
Somador de 8 bits com entrada de carry in, utilizando abordagem por fluxo de dados e operadores aritm√©ticos.

## Resolu√ß√£o
Dessa vez ser√° um pouco mais simples de descrever o somador, uma vez que agora, tal bloco combinacional ser√° descrito por meio das express√µes que definem a sa√≠da do mesmo. Dessa forma, a express√£o obtida ser√° muito mais simples de ser representada por meio dos operadores aritm√©ticos.

## Descri√ß√£o em *systemverilog*

~~~
module oitobitsadder (
    // declarando as entradas "a" e "b" em 8 bits do somador 
    input logic [7:0] a, b,
    // declarando o carry-in do somador
    input logic cin,
    // declarando a sa√≠da da soma do somador em 8 bits 
    output logic [7:0] s, 
    // declarando o carry-out do somador 
    output logic cout
);
    // definindo as express√µes para as sa√≠das do somador 
    // ~ usando operadores aritm√©ticos 
    assign s = a + b + cin; 
    assign cout = a + b + cin; 
    
endmodule 
~~~

# Problema 10
Um circuito que realiza, conjuntamente, as opera√ß√µes de soma e subtra√ß√£o entre n√∫meros de 8 bits a partir de dois sinais de controle ùëÄ, de tal forma que quando ùëÄ = 0 o circuito dever√° realizar a soma dos dois n√∫meros e quando ùëÄ = 1, o circuito realizar√° a subtra√ß√£o de dois n√∫meros. Utilize o somador de 8 bits projetado no item (9) em conjunto com portas l√≥gicas adicionais, utilizando a abordagem por hierarquia.

## Resolu√ß√£o

Para projetar este circuito, ser√° necess√°rio ter uma boa interpreta√ß√£o e entender que com um mesmo somador de 8 bits, √© poss√≠vel criar um subtrator de 8 bits utilizando um conjunto de portas l√≥gicas adicionais, especificamente, as portas XOR. Dessa forma, a partir do sinal de controle *M*, haver√£o momentos em que o *adder* ir√° se comportar como somador (*M* = 0) e haver√£o momentos em que o *adder* ir√° se comportar como subtrator (*M* = 0)  

Inicialmente, podemos entender que em um somador, as entradas se  comportar de tal forma:

*A + B*

E em um subtrator temos que: 

*A - B*

Contudo, podemos interpretar esta subtra√ß√£o como a soma de *A* com o valor negativo de *B*. Portanto: 

*A - B = A + (-B)*

Consequentemente, quando for a hora do *adder* se comportar como subtrator ele ir√° simplesmente somar o valor de *A* com o valor negativo de *B*. Nesse sentido, o valor negativo de *B* ser√° definido como o complemento de dois de *B*.

Teoricamente, para realizar o complemento de dois, primeiramente inverte-se cada bit do sinal e, em seguida, soma-se mais 1.

Na pr√°tica, as portas XOR's implementadas no circuito servem para inverter cada um dos 8 bits de *B* e no *carry-in*, √© adicionado o valor de 1 para realizar o complemento de 2 de *B*.

A imagem abaixo, tirada de uma aula no youtube (cujo link estar√° nas refer√™ncias bibliogr√°ficas) representa esta mesma l√≥gica sendo aplicada para 4 bits.

![adder_sub](/Problema%2010/Problema%2010%20-%20Assets/fonte%20logica%20digital%20fabrica%20de%20noobs.jpg)

## Descri√ß√£o em *systemverilog*

Primeiramente, ser√° criado um bloco menor o qual ser√° respons√°vel por descrever a estrutra do somador de 8 bits. Nesse caso, ser√° reaproveitada a descri√ß√£o do item (9), o qual j√° descreve um somador de 8 bits em termos de suas express√µes. S√≥ que, ao inv√©s de pegar o somador de 8 bits j√° feito, este ser√° inst√¢nciado por um bloco menor: por um somador de 1 bit.

~~~
// criando o m√≥dulo do menor bloco l√≥gico: 1-bit adder 
module umbitadder (
    // entradas do somador de 1 bit
    input logic a, b, cin,
    // sa√≠das do somador de 1 bit
    output logic s, cout
);
    // atribuindo as express√µes de sa√≠da, baseadas nas entradas
    assign {s, cout} = a + b + cin; 
    // concatenei "s" e "cout", j√° que a express√£o √© a mesma para os 2 bits 
endmodule 

// criando o m√≥dulo do 8-bits adder 
module oitobitsadder (
    // entradas A e B de 8 bits
    input logic [7:0] A, B,
    // cin
    input logic cin,
    // sa√≠da da soma de 8 bits 
    output logic [7:0] s,
    // cout
    output logic cout
);

    // definindo o sinal intermedi√°rio de carry, o qual ir√° passar entre cada 1-bit adder
    logic [7:0] carry;

    // instanciando o 8-bits adder
    umbitadder FA0 (.a(A[0]), .b(B[0]), .cin(cin), .s(s[0]), .cout(carry[0]));
    umbitadder FA1 (.a(A[1]), .b(B[1]), .cin(carry[0]), .s(s[1]), .cout(carry[1]));
    umbitadder FA2 (.a(A[2]), .b(B[2]), .cin(carry[1]), .s(s[2]), .cout(carry[2]));
    umbitadder FA3 (.a(A[3]), .b(B[3]), .cin(carry[2]), .s(s[3]), .cout(carry[3]));
    umbitadder FA4 (.a(A[4]), .b(B[4]), .cin(carry[3]), .s(s[4]), .cout(carry[4]));
    umbitadder FA5 (.a(A[5]), .b(B[5]), .cin(carry[4]), .s(s[5]), .cout(carry[5]));
    umbitadder FA6 (.a(A[6]), .b(B[6]), .cin(carry[5]), .s(s[6]), .cout(carry[6]));
    umbitadder FA0 (.a(A[7]), .b(B[7]), .cin(carry[6]), .s(s[7]), .cout(cout)); 
    // obs: carry[7] = cout
endmodule
~~~

Em seguida, no m√≥dulo principal, ser√° descrito o somador/subtrator, usando como base o somador de 8 bits.

~~~
// modulo principal -> √© aqui que o somador/subtrator de 8 bits ser√° descrito
module main (
    // declarando as entradas de 8 bits A e B
    input logic [7:0] A, B,
    // declarando o sinal de controle M como uma entrada do bloco l√≥gico  
    input logic M,
    // declarando a sa√≠da do somador/subtrator => resultado da opera√ß√£o
    output logic resultado, 
    // cout 
    output logic cout  
);
    // declarando os sinais intermedi√°rios: 
    logic [7:0] B_c2;  // sinal respons√°vel por inverter cada bit da entrada "B"
    logic cin; // "cin" n√£o ser√° uma entrada mais sim um sinal intermedi√°rio. 
    // Isso acontece pq "cin" estar√° ligado √† entrada de controle M, para somar + 1, para fazer o complemento de 2, logo, "cin = M"

    // CASO M = 1 -> INVERTE "B" [complemento de 2], SE N√ÉO -> B
    assign B_c2 = B ^ {8{M}};
    // implementando uma XOR pra cada bit de M, que ser√° ou M = 00000000 (0) ou M = 11111111 (1) (precisa fazer isso para que a XOR consiga lidar com os 8 bits vindos de "B")
    assign cin = M;

    // INSTANCIANDO O 8-BITS ADDER/SUB, tendo como base o somador de 8-bits descrito anteriormente
    oitobitsadder main (
        .A(A),
        .B(B),
        .cin(cin),
        .s(resultado),
        .cout(cout)  
    );

endmodule
~~~

# Problema 11
Um circuito multiplicador de dois n√∫meros de 8 bits, utilizando abordagem por fluxo de dados e operadores aritm√©ticos.

## Resolu√ß√£o
A forma de descrever este circuito √© similar ao problema 09.

## Descri√ß√£o em *systemverilog*

~~~
module multiplicador (
    // declarando as entradas em 8 bits
    input logic [7:0] a, b,
    // declarando a sa√≠da do multiplicador em 16 bits (dobro) 
    output logic [15:0] p
);
    // definindo as express√µes l√≥gicas da s√°ida e do carry-out
    assign p = a * b;
endmodule 
~~~

# Problema 12
Uma unidade l√≥gico-aritm√©tica com a seguinte tabela de opera√ß√£o utilizando a abordagem que desejar:

![P12OPC](/Problema%2012/Problema%2012%20-%20Assets/opcode.jpg)

Sendo ùê¥ e ùêµ dois n√∫meros de 8 bits.

## Resolu√ß√£o

Para este projeto ser√° necess√°rio utilizar a abordagem comportamental. Especificamente, ser√° aplicado um procedimento *always* o qual ir√° definir por meio de uma estrutura *case*, todos as opera√ß√µes que a ALU ir√° fazer baseado nas combina√ß√µes formadas pelos bits do *op code*.   

## Descri√ß√£o em *systemverilog*

~~~
module neoalu(
    //definindo os bits do opcode
    input logic opc2, opc1, opc0,
    //definindo a entrada 8 bits de a
    input logic [7:0] a,
    //definindo a entrada 8 bits de b  
    input logic [7:0] b,
    //sa√≠da 8 bits da alu
    output logic [7:0] s
);

always @(*) begin
    case ({opc2,opc1, opc0}) //concatenei aqui pra formar uma s√©rie de 3 bits do opcode
        // cada opera√ß√£o relacionada √† cada opcode ser√° descrita aqui
        // aplicando uma abordagem por fluxo de dados
        3'b000: s = a | b; // a or b -> opcode = 000
        3'b001: s = a & b; // a and b -> opcode = 001
        3'b010: s = a ^ b; // a xor b -> opcode = 010
        3'b011: s = ~a; // ~a -> opcode = 011
        3'b100: s = a + b; // a + b -> opcode = 100
        3'b101: s = a - b; // a - b -> opcode = 101
        3'b110: s = a + 1; // a + 1 -> opcode = 110
        3'b111: s = b + 1; // b + 1 -> opcode = 111
        // caso padr√£o (default): recebe um valor de 8 bit indefido e diferente do opcode. Ou seja, caso padr√£o = fora do escopo do opcode = erro
        default: s = 8'bx; // resultado inv√°lido
    endcase
end
endmodule
~~~

# Refer√™ncias

-  F√°brica de Noobs. L√≥gica Digital #17 - Somadores e Subtratores. YouTube, 16 de dez. de 2019. Dispon√≠vel em: [L√≥gica Digital #17 - Somadores e Subtratores](https://www.youtube.com/watch?v=IQkYBmNVo_U). Acesso em: 22 de out. de 2024.