# Lista de Projeto 01 - Circuitos Digitais
Projeto direcionado √† disciplina de Circuitos Digitais, ministrada pelo Prof Dr Pedro Thiago Val√©rio de Souza no per√≠odo 2024.1, na Universidade Federal Rural do Semi-√Årido (UFERSA).

# Autores 
- Caio Barreto Meyer | [Caio B. Meyer](https://github.com/TaiCaio) 
- Guilherme Gabriel Saldanha Pereira | [OGuilhermeGabriel](https://github.com/OGuilhermeGabriel)

# Sum√°rio 
- [Problema 01](#problema-01)
- [Problema 02](#problema-02)
- [Problema 03](#problema-03)
- [Problema 04](#problema-04)
- [Problema 05](#problema-05)
- [Problema 06](#problema-06)
- [Problema 07](#problema-07)
- [Problema 08](#problema-08)
- [Problema 09](#problema-09)
- [Problema 10](#problema-10)
- [Problema 11](#problema-11)
- [Problema 12](#problema-12)

# Lista de Projetos 
Implemente os seguintes circuitos em SystemVerilog utilizando a abordagem designada:

# Problema 01
Um circuito gerador de paridade impar de um n√∫mero de 8 bits utilizando fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o
Um gerador de paridade √≠mpar pode ser representado por um circuito composto por 8 entradas (para 8 bits) associados por XNOR's de forma cascata. Nesse sentido, a sa√≠da ir√° gerar um √∫nico bit: Caso a sequ√™ncia de valores dos 8 bits tenha uma quantidade de 1's par, o bit de paridade gerado ir√° ter o valor 1. Caso a sequ√™ncia de valores dos 8 bits tenha uma quantidade de 1's √≠mpar, o bit de paridade gerado ir√° ter o valor 0.

Como o problema pede para ser resolvido por fluxo de dados, a descri√ß√£o do circuito foi feita em termos das suas pr√≥prias express√µes l√≥gicas, relacionando as entradas do gerador com a sa√≠da do mesmo. 

## Descri√ß√£o em *systemverilog* 
~~~
module paridade(
    //descrevendo os 8 bits de entrada do gerador
    input logic b7, b6, b5, b4, b3, b2, b1, b0,
    //descrevendo o bit de sa√≠da do gerador
    output logic paridade
);
    //express√£o de sa√≠da do gerador de paridade √≠mpar
    assign paridade = ~(b7 ^ b6 ^ b5 ^ b4 ^ b3 ^ b2 ^ b1 ^ b0);
endmodule
~~~

# Problema 02
Um decodificador para display de sete segmentos √¢nodo comum, que seja capaz de representar os d√≠gitos em hexadecimal. Utilize a abordagem comportamental e estrutura case.

## Resolu√ß√£o

A primeira coisa a se fazer para projetar este decodificador √©, especificamente, determinar como ser√£o os segmentos quando eles estiverem ligados. 

A imagem abaixo mostra o modelo adotado para representar os d√≠gitos em hexadecimal.

![P2_Display](/Problema%2002/Problema%2002%20-%20Assets/segmentos.png)

Em seguida, faz-se necess√°rio fazer a tabela verdade, para relacionar cada d√≠gito hexadecimal (formada por 4 bits) com a sequ√™ncia de segmentos ligados e desligados que formam o d√≠gito visualmente. 

- TABELA VERDADE

 *b3* | *b2* | *b1* | *b0* |*a*|*b*|*c*|*d*|*e*|*f*|*g*| 
 -----| -----| -----| -----| --| --| --| --| --| --| --|  
  0   |  0   |  0   |  0   | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
  0   |  0   |  0   |  1   | 1 | 0 | 0 | 1 | 1 | 1 | 1 |
  0   |  0   |  1   |  0   | 0 | 0 | 1 | 0 | 0 | 1 | 0 |
  0   |  0   |  1   |  1   | 0 | 0 | 0 | 0 | 1 | 1 | 0 |
  0   |  1   |  0   |  0   | 1 | 0 | 0 | 1 | 1 | 0 | 0 |
  0   |  1   |  0   |  1   | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
  0   |  1   |  1   |  0   | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
  0   |  1   |  1   |  1   | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
  1   |  0   |  0   |  0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
  1   |  0   |  0   |  1   | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
  1   |  0   |  1   |  0   | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
  1   |  0   |  1   |  1   | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
  1   |  1   |  0   |  0   | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
  1   |  1   |  0   |  1   | 1 | 0 | 0 | 0 | 0 | 1 | 0 |
  1   |  1   |  1   |  0   | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
  1   |  1   |  1   |  1   | 0 | 1 | 1 | 1 | 0 | 0 | 0 |

## Descri√ß√£o em *systemverilog*

~~~
module display(
    //definindo a sequ√™ncia de bits que definir√° o segmento
    input logic [3:0] digito,
    //definindo os 7 segmentos do display
    output logic [6:0] segmento 
);
    //aplicando um always_combinacional p/ o bloco condicional
    always_comb begin 
        case(digito)
            4'h0 : segmento = 7'b0000001; //segmento para o digito hex 0
            4'h1 : segmento = 7'b1001111; //segmento para o digito hex 1
            4'h2 : segmento = 7'b0010010; //segmento para o digito hex 2
            4'h3 : segmento = 7'b0000110; //segmento para o digito hex 3
            4'h4 : segmento = 7'b1001100; //segmento para o digito hex 4
            4'h5 : segmento = 7'b0100100; //segmento para o digito hex 5
            4'h6 : segmento = 7'b0100000; //segmento para o digito hex 6
            4'h7 : segmento = 7'b0001111; //segmento para o digito hex 7
            4'h8 : segmento = 7'b0000000; //segmento para o digito hex 8
            4'h9 : segmento = 7'b0000100; //segmento para o digito hex 9
            4'hA : segmento = 7'b0001000; //segmento para o digito hex A
            4'hB : segmento = 7'b1100000; //segmento para o digito hex B
            4'hC : segmento = 7'b0110001; //segmento para o digito hex C
            4'hD : segmento = 7'b1000010; //segmento para o digito hex D
            4'hE : segmento = 7'b0110000; //segmento para o digito hex E
            4'hF : segmento = 7'b0111000; //segmento para o digito hex F
            default : segmento = 7'b1111111; // segmento para condi√ß√µes imposs√≠veis
        endcase
    end
endmodule 
~~~

Utilizando a abordagem comportamental, onde o circuito deve ser descrito em termos do seu comportamento algoritmo, foi implementada ent√£o a estrutura *case* dentro do procedimento *always_comb*, sendo um procedimento *always* utilizado para mapear circuitos l√≥gicos combinacionais, como este circuito o qual descreve o display. 

Al√©m disso, vale mencionar a importancia da implementa√ß√£o da estrutura *case*, a qual descreve as condi√ß√µes de cada dig√≠to hexadecimal para cada sequ√™ncia dos 7 segmentos de forma r√°pida e pr√°tica. Vale salientar ainda que, em termos de projeto, a escolha "*default*" foi atribuida para quando nenhum dos d√≠gitos hexadecimais registrados seja selecionado, onde no display, nenhum segmento ser√° aceso. 

# Problema 03
Um decodificador 3x8 com entrada de habilita√ß√£o utilizando fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o

Um decodificador 3x8 √© um bloco l√≥gico combinacional definido por 3 entradas e 8 sa√≠das, onde para cada combina√ß√£o das entradas, uma √∫nica sa√≠da ser√° ativada. Dessa forma, a tabela verdade pode ser representada dessa forma:
 
- TABELA VERDADE

 *b2* | *b1* | *b0* |*e7*|*e6*|*e5*|*e4*|*e3*|*e2*|*e1*|*e0*| 
 -----| -----| -----| -- | -- | -- | -- | -- | -- | -- | -- |  
  0   |  0   |  0   | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 1  |
  0   |  0   |  1   | 0  | 0  | 0  | 0  | 0  | 0  | 1  | 0  |
  0   |  1   |  0   | 0  | 0  | 0  | 0  | 0  | 1  | 0  | 0  |
  0   |  1   |  1   | 0  | 0  | 0  | 0  | 1  | 0  | 0  | 0  |
  1   |  0   |  0   | 0  | 0  | 0  | 1  | 0  | 0  | 0  | 0  |
  1   |  0   |  1   | 0  | 0  | 1  | 0  | 0  | 0  | 0  | 0  |
  1   |  1   |  0   | 0  | 1  | 0  | 0  | 0  | 0  | 0  | 0  |
  1   |  1   |  1   | 1  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |

## Descri√ß√£o em *systemverilog*

~~~
module decodificador(
    //colocando as entradas do decodificador 
    input logic b0,b1,b2, //b2 = X, b1 = Y, b0 = Z
    //colocando as sa√≠das do decodificador
    output logic e0, e1, e2, e3, e4, e5, e6, e7
);
    // atribuindo as express√µes para cada sa√≠da do decodificador (as 8)
    assign e0 = ((~b2)&(~b1)&(~b0));
    assign e1 = ((~b2)&(~b1)&(b0));
    assign e2 = ((~b2)&(b1)&(~b0));
    assign e3 = ((~b2)&(b1)&(b0));
    assign e4 = ((b2)&(~b1)&(~b0));
    assign e5 = ((b2)&(~b1)&(b0));
    assign e6 = ((b2)&(b1)&(~b0));
    assign e7 = ((b2)&(b1)&(b0));
endmodule 
~~~

# Problema 04
Um multiplexador 4x1 utilizando fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o
O mux 4x1 √© um bloco l√≥gico combinacional contendo quatro entradas e uma √∫nica sa√≠da, onde as entradas s√£o selecionadas a partir dos bits de sele√ß√£o que comp√µe a chave seletora. Dessa forma, como o que determina as combina√ß√µes das entradas s√£o os bits de sele√ß√£o, faz-se necess√°rio criar uma tabela verdade relacionando os bits da chave seletora com a sa√≠da do mux. 

- TABELA VERDADE 

 *s1* | *s0* |  *f* |
  --  |  --  | ---  |
   0  |   0  | *i0* |
   0  |   1  | *i1* |
   1  |   0  | *i2* |
   1  |   1  | *i3* |

Como tratasse de uma abordagem por fluxo de dados e operadores l√≥gicos, faz-se necess√°rio encontrar a express√£o que define a sa√≠da do mux. Uma vez que o multiplexador pode ser projetado com portas l√≥gicas como mostra a figura a baixo, √© poss√≠vel encontrar a express√£o l√≥gica para a sa√≠da *f*.

![P4_mux_logic](/Problema%2004/Problema%2004%20-%20Assets/mux_logic.jpg)

## Descri√ß√£o em *systemverilog*
~~~
module mux(
    //declarando as entradas 
    input logic i0, i1, i2, i3,
    //declarando a chave seletora (que s√£o entradas tamb√©m)
    input logic s0, s1,
    //declarando a sa√≠da
    output logic f
);
    //atribuindo a express√£o l√≥gica para a sa√≠da do mux 4x1
    assign f = (i0&(~s1)&(~s0)) | (i1&(~s1)&s0) | (i2&s1&(~s0)) | (i3&s1&s0);
endmodule
~~~

# Problema 05
Um multiplexador 4x1 de 8 bits utilizando abordagem comportamental e estrutura case.

## Resolu√ß√£o
O mesmo bloco combinacional ser√° descrito, s√≥ que desta vez, ser√° feito por meio de outra abordagem.

Ao inv√©s do circuito ser descrito em termos de suas express√µes de sa√≠da, ele ser√° descrito baseado no seu comportamento algor√≠tmico, utilizando a estrutura "*case*" por meio dentro de um procedimento "*always*".
## Descri√ß√£o em *systemverilog*

~~~
module mux2 (
    //declarando as 4 entradas 
    input logic [3:0] i,
    //declarando os 2 bits seletores 
    input logic [1:0] s,
    //declarando a sa√≠da 
    output logic f 
);
    always_comb begin
        case (s)
            2'b00 : f = i[0]; 
            2'b01 : f = i[1];
            2'b10 : f = i[2];
            2'b11 : f = i[3];
            //valor padr√£o caso a combina√ß√£o de bits de sele√ß√£o d√™ algo imposs√≠vel
            default: f = 1'b0; // sa√≠da = 0 
        endcase 
    end
endmodule
~~~

Dessa vez, as entradas normais e entradas de sele√ß√£o foram concatenadas e, com o procedimento "*always_comb*", fora utilizada a estrutura condicional "*case*". Contudo, note que a l√≥gica por tr√°s da descri√ß√£o deste circuito combinacional ainda continua a mesma.

# Problema 06
Meio somador, utilizando abordagem por fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*

# Problema 07
Somador completo, utilizando abordagem por fluxo de dados e operadores l√≥gicos.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*

# Problema 08
Somador de 4 bits com entrada de carry in, utilizando um conjunto de somadores completos e abordagem hierarquica.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*

# Problema 09
Somador de 8 bits com entrada de carry in, utilizando abordagem por fluxo de dados e operadores aritm√©ticos.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*

# Problema 10
Um circuito que realiza, conjuntamente, as opera√ß√µes de soma e subtra√ß√£o entre n√∫meros de 8 bits a partir de dois sinais de controle ùëÄ, de tal forma que quando ùëÄ = 0 o circuito dever√° realizar a soma dos dois n√∫meros e quando ùëÄ = 1, o circuito realizar√° a subtra√ß√£o de dois n√∫meros. Utilize o somador de 8 bits projetado no item (9) em conjunto com portas l√≥gicas adicionais, utilizando a abordagem por hierarquia.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*

# Problema 11
Um circuito multiplicador de dois n√∫meros de 8 bits, utilizando abordagem por fluxo de dados e
operadores aritm√©ticos.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*

# Problema 12
Uma unidade l√≥gico-aritm√©tica com a seguinte tabela de opera√ß√£o utilizando a abordagem que desejar:

![P12OPC](/Problema%2012/Problema%2012%20-%20Assets/opcode.jpg)

Sendo ùê¥ e ùêµ dois n√∫meros de 8 bits.

## Resolu√ß√£o

## Descri√ß√£o em *systemverilog*