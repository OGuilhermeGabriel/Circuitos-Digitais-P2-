# Lista de Projeto 01 - Circuitos Digitais
Projeto direcionado Ã  disciplina de Circuitos Digitais, ministrada pelo Prof Dr Pedro Thiago ValÃ©rio de Souza no perÃ­odo 2024.1, na Universidade Federal Rural do Semi-Ãrido (UFERSA).

# Autores 
- Caio Barreto Meyer | [Caio B. Meyer](https://github.com/TaiCaio) 
- Guilherme Gabriel Saldanha Pereira | [OGuilhermeGabriel](https://github.com/OGuilhermeGabriel)

# SumÃ¡rio 
- [Problema 01](#problema-01)
- [Problema 02](#problema-02)
- [Problema 03](#problema-03)
- [Problema 04](#problema-04)
- [Problema 05](#problema-05)
- [Problema 06](#problema-06)
- [Problema 07](#problema-07)
- [Problema 08](#problema-08)
- [Problema 09](#problema-09)
- [Problema 10](#problema-10)
- [Problema 11](#problema-11)
- [Problema 12](#problema-12)

# Lista de Projetos 
Implemente os seguintes circuitos em SystemVerilog utilizando a abordagem designada:

# Problema 01
Um circuito gerador de paridade impar de um nÃºmero de 8 bits utilizando fluxo de dados e operadores lÃ³gicos.

## ResoluÃ§Ã£o
Um gerador de paridade Ã­mpar pode ser representado por um circuito composto por 8 entradas (para 8 bits) associados por XNOR's de forma cascata. Nesse sentido, a saÃ­da irÃ¡ gerar um Ãºnico bit: Caso a sequÃªncia de valores dos 8 bits tenha uma quantidade de 1's par, o bit de paridade gerado irÃ¡ ter o valor 1. Caso a sequÃªncia de valores dos 8 bits tenha uma quantidade de 1's Ã­mpar, o bit de paridade gerado irÃ¡ ter o valor 0.

Como o problema pede para ser resolvido por fluxo de dados, a descriÃ§Ã£o do circuito foi feita em termos das suas prÃ³prias expressÃµes lÃ³gicas, relacionando as entradas do gerador com a saÃ­da do mesmo. 

## DescriÃ§Ã£o em *systemverilog* 
~~~
module paridade(
    //descrevendo os 8 bits de entrada do gerador
    input logic b7, b6, b5, b4, b3, b2, b1, b0,
    //descrevendo o bit de saÃ­da do gerador
    output logic paridade
);
    //expressÃ£o de saÃ­da do gerador de paridade Ã­mpar
    assign paridade = ~(b7 ^ b6 ^ b5 ^ b4 ^ b3 ^ b2 ^ b1 ^ b0);
endmodule
~~~

# Problema 02
Um decodificador para display de sete segmentos Ã¢nodo comum, que seja capaz de representar os dÃ­gitos em hexadecimal. Utilize a abordagem comportamental e estrutura case.

## ResoluÃ§Ã£o

A primeira coisa a se fazer para projetar este decodificador Ã©, especificamente, determinar como serÃ£o os segmentos quando eles estiverem ligados. 

A imagem abaixo mostra o modelo adotado para representar os dÃ­gitos em hexadecimal.

![P2_Display](/Problema%2002/Problema%2002%20-%20Assets/segmentos.png)

Em seguida, faz-se necessÃ¡rio fazer a tabela verdade, para relacionar cada dÃ­gito hexadecimal (formada por 4 bits) com a sequÃªncia de segmentos ligados e desligados que formam o dÃ­gito visualmente. 

- TABELA VERDADE

 *b3* | *b2* | *b1* | *b0* |*a*|*b*|*c*|*d*|*e*|*f*|*g*| 
 -----| -----| -----| -----| --| --| --| --| --| --| --|  
  0   |  0   |  0   |  0   | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
  0   |  0   |  0   |  1   | 1 | 0 | 0 | 1 | 1 | 1 | 1 |
  0   |  0   |  1   |  0   | 0 | 0 | 1 | 0 | 0 | 1 | 0 |
  0   |  0   |  1   |  1   | 0 | 0 | 0 | 0 | 1 | 1 | 0 |
  0   |  1   |  0   |  0   | 1 | 0 | 0 | 1 | 1 | 0 | 0 |
  0   |  1   |  0   |  1   | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
  0   |  1   |  1   |  0   | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
  0   |  1   |  1   |  1   | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
  1   |  0   |  0   |  0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
  1   |  0   |  0   |  1   | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
  1   |  0   |  1   |  0   | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
  1   |  0   |  1   |  1   | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
  1   |  1   |  0   |  0   | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
  1   |  1   |  0   |  1   | 1 | 0 | 0 | 0 | 0 | 1 | 0 |
  1   |  1   |  1   |  0   | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
  1   |  1   |  1   |  1   | 0 | 1 | 1 | 1 | 0 | 0 | 0 |

## DescriÃ§Ã£o em *systemverilog*

~~~
module display(
    //definindo a sequÃªncia de bits que definirÃ¡ o segmento
    input logic [3:0] digito,
    //definindo os 7 segmentos do display
    output logic [6:0] segmento 
);
    //aplicando um always_combinacional p/ o bloco condicional
    always_comb begin 
        case(digito)
            4'h0 : segmento = 7'b0000001; //segmento para o digito hex 0
            4'h1 : segmento = 7'b1001111; //segmento para o digito hex 1
            4'h2 : segmento = 7'b0010010; //segmento para o digito hex 2
            4'h3 : segmento = 7'b0000110; //segmento para o digito hex 3
            4'h4 : segmento = 7'b1001100; //segmento para o digito hex 4
            4'h5 : segmento = 7'b0100100; //segmento para o digito hex 5
            4'h6 : segmento = 7'b0100000; //segmento para o digito hex 6
            4'h7 : segmento = 7'b0001111; //segmento para o digito hex 7
            4'h8 : segmento = 7'b0000000; //segmento para o digito hex 8
            4'h9 : segmento = 7'b0000100; //segmento para o digito hex 9
            4'hA : segmento = 7'b0001000; //segmento para o digito hex A
            4'hB : segmento = 7'b1100000; //segmento para o digito hex B
            4'hC : segmento = 7'b0110001; //segmento para o digito hex C
            4'hD : segmento = 7'b1000010; //segmento para o digito hex D
            4'hE : segmento = 7'b0110000; //segmento para o digito hex E
            4'hF : segmento = 7'b0111000; //segmento para o digito hex F
            default : segmento = 7'b1111111; // segmento para condiÃ§Ãµes impossÃ­veis
        endcase
    end
endmodule 
~~~

Utilizando a abordagem comportamental, onde o circuito deve ser descrito em termos do seu comportamento algoritmo, foi implementada entÃ£o a estrutura *case* dentro do procedimento *always_comb*, sendo um procedimento *always* utilizado para mapear circuitos lÃ³gicos combinacionais, como este circuito o qual descreve o display. 

AlÃ©m disso, vale mencionar a importancia da implementaÃ§Ã£o da estrutura *case*, a qual descreve as condiÃ§Ãµes de cada digÃ­to hexadecimal para cada sequÃªncia dos 7 segmentos de forma rÃ¡pida e prÃ¡tica. Vale salientar ainda que, em termos de projeto, a escolha "*default*" foi atribuida para quando nenhum dos dÃ­gitos hexadecimais registrados seja selecionado, onde no display, nenhum segmento serÃ¡ aceso. 

# Problema 03
Um decodificador 3x8 com entrada de habilitaÃ§Ã£o utilizando fluxo de dados e operadores lÃ³gicos.

## ResoluÃ§Ã£o

Um decodificador 3x8 Ã© um bloco lÃ³gico combinacional definido por 3 entradas e 8 saÃ­das, onde para cada combinaÃ§Ã£o das entradas, uma Ãºnica saÃ­da serÃ¡ ativada. Dessa forma, a tabela verdade pode ser representada dessa forma:
 
- TABELA VERDADE

 *b2* | *b1* | *b0* |*e7*|*e6*|*e5*|*e4*|*e3*|*e2*|*e1*|*e0*| 
 -----| -----| -----| -- | -- | -- | -- | -- | -- | -- | -- |  
  0   |  0   |  0   | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 1  |
  0   |  0   |  1   | 0  | 0  | 0  | 0  | 0  | 0  | 1  | 0  |
  0   |  1   |  0   | 0  | 0  | 0  | 0  | 0  | 1  | 0  | 0  |
  0   |  1   |  1   | 0  | 0  | 0  | 0  | 1  | 0  | 0  | 0  |
  1   |  0   |  0   | 0  | 0  | 0  | 1  | 0  | 0  | 0  | 0  |
  1   |  0   |  1   | 0  | 0  | 1  | 0  | 0  | 0  | 0  | 0  |
  1   |  1   |  0   | 0  | 1  | 0  | 0  | 0  | 0  | 0  | 0  |
  1   |  1   |  1   | 1  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |

## DescriÃ§Ã£o em *systemverilog*

~~~
module decodificador(
    //colocando as entradas do decodificador 
    input logic b0,b1,b2, //b2 = X, b1 = Y, b0 = Z
    //colocando as saÃ­das do decodificador
    output logic e0, e1, e2, e3, e4, e5, e6, e7
);
    // atribuindo as expressÃµes para cada saÃ­da do decodificador (as 8)
    assign e0 = ((~b2)&(~b1)&(~b0));
    assign e1 = ((~b2)&(~b1)&(b0));
    assign e2 = ((~b2)&(b1)&(~b0));
    assign e3 = ((~b2)&(b1)&(b0));
    assign e4 = ((b2)&(~b1)&(~b0));
    assign e5 = ((b2)&(~b1)&(b0));
    assign e6 = ((b2)&(b1)&(~b0));
    assign e7 = ((b2)&(b1)&(b0));
endmodule 
~~~

# Problema 04
Um multiplexador 4x1 utilizando fluxo de dados e operadores lÃ³gicos.

## ResoluÃ§Ã£o
O mux 4x1 Ã© um bloco lÃ³gico combinacional contendo quatro entradas e uma Ãºnica saÃ­da, onde as entradas sÃ£o selecionadas a partir dos bits de seleÃ§Ã£o que compÃµe a chave seletora. Dessa forma, como o que determina as combinaÃ§Ãµes das entradas sÃ£o os bits de seleÃ§Ã£o, faz-se necessÃ¡rio criar uma tabela verdade relacionando os bits da chave seletora com a saÃ­da do mux. 

- TABELA VERDADE 

 *s1* | *s0* |  *f* |
  --  |  --  | ---  |
   0  |   0  | *i0* |
   0  |   1  | *i1* |
   1  |   0  | *i2* |
   1  |   1  | *i3* |

Como tratasse de uma abordagem por fluxo de dados e operadores lÃ³gicos, faz-se necessÃ¡rio encontrar a expressÃ£o que define a saÃ­da do mux. Uma vez que o multiplexador pode ser projetado com portas lÃ³gicas como mostra a figura a baixo, Ã© possÃ­vel encontrar a expressÃ£o lÃ³gica para a saÃ­da *f*.

![P4_mux_logic](/Problema%2004/Problema%2004%20-%20Assets/mux_logic.jpg)

## DescriÃ§Ã£o em *systemverilog*
~~~
module mux(
    //declarando as entradas 
    input logic i0, i1, i2, i3,
    //declarando a chave seletora (que sÃ£o entradas tambÃ©m)
    input logic s0, s1,
    //declarando a saÃ­da
    output logic f
);
    //atribuindo a expressÃ£o lÃ³gica para a saÃ­da do mux 4x1
    assign f = (i0&(~s1)&(~s0)) | (i1&(~s1)&s0) | (i2&s1&(~s0)) | (i3&s1&s0);
endmodule
~~~

# Problema 05
Um multiplexador 4x1 de 8 bits utilizando abordagem comportamental e estrutura case.

## ResoluÃ§Ã£o
O mesmo bloco combinacional serÃ¡ descrito, sÃ³ que desta vez, serÃ¡ feito por meio de outra abordagem.

Ao invÃ©s do circuito ser descrito em termos de suas expressÃµes de saÃ­da, ele serÃ¡ descrito baseado no seu comportamento algorÃ­tmico, utilizando a estrutura "*case*" por meio dentro de um procedimento "*always*".
## DescriÃ§Ã£o em *systemverilog*

~~~
module mux2 (
    //declarando as 4 entradas 
    input logic [3:0] i,
    //declarando os 2 bits seletores 
    input logic [1:0] s,
    //declarando a saÃ­da 
    output logic f 
);
    always_comb begin
        case (s)
            2'b00 : f = i[0]; 
            2'b01 : f = i[1];
            2'b10 : f = i[2];
            2'b11 : f = i[3];
            //valor padrÃ£o caso a combinaÃ§Ã£o de bits de seleÃ§Ã£o dÃª algo impossÃ­vel
            default: f = 1'b0; // saÃ­da = 0 
        endcase 
    end
endmodule
~~~

Dessa vez, as entradas normais e entradas de seleÃ§Ã£o foram concatenadas e, com o procedimento "*always_comb*", fora utilizada a estrutura condicional "*case*". Contudo, note que a lÃ³gica por trÃ¡s da descriÃ§Ã£o deste circuito combinacional ainda continua a mesma.

# Problema 06
Meio somador, utilizando abordagem por fluxo de dados e operadores lÃ³gicos.

## ResoluÃ§Ã£o
TambÃ©m conhecido como *half adder*, tratasse de um circuito que soma duas entradas e a saÃ­da retorna a soma das duas entradas alÃ©m do carry-out, bit necessÃ¡rio caso a soma seja 1+1.

## DescriÃ§Ã£o em *systemverilog*

~~~
module halfadder (
    //definindo as entradas do half-adder
    input logic a, b,
    //definindo as saÃ­das do half-adder
    output logic s, cout
);
    //definindo as expressÃµes das saÃ­das do meio-somador
    assign s = a ^ b;
    assign cout = a & b;                                                                

endmodule 
~~~

# Problema 07
Somador completo, utilizando abordagem por fluxo de dados e operadores lÃ³gicos.

## ResoluÃ§Ã£o
TambÃ©m conhecidos como *full-adder*, a Ãºnica diferenÃ§a entre os somadores completos para os meio-somadores Ã© a presenÃ§a da entrada de carry-in no bloco lÃ³gico.

## DescriÃ§Ã£o em *systemverilog*
~~~
module fulladder(
    //declarando as entradas do full-adder
    input logic a,b,cin, 
    //declarando as saÃ­das do full-adder
    output logic s,cout
);
    //declarando as expressÃµes de saÃ­da do full-adder
    assign s = a ^ b ^ cin;
    assign cout = (a&b) | (a&cin) | (b&cin); 
endmodule
~~~

# Problema 08
Somador de 4 bits com entrada de carry in, utilizando um conjunto de somadores completos e abordagem hierarquica.

## ResoluÃ§Ã£o

## DescriÃ§Ã£o em *systemverilog*

# Problema 09
Somador de 8 bits com entrada de carry in, utilizando abordagem por fluxo de dados e operadores aritmÃ©ticos.

## ResoluÃ§Ã£o

## DescriÃ§Ã£o em *systemverilog*

# Problema 10
Um circuito que realiza, conjuntamente, as operaÃ§Ãµes de soma e subtraÃ§Ã£o entre nÃºmeros de 8 bits a partir de dois sinais de controle ğ‘€, de tal forma que quando ğ‘€ = 0 o circuito deverÃ¡ realizar a soma dos dois nÃºmeros e quando ğ‘€ = 1, o circuito realizarÃ¡ a subtraÃ§Ã£o de dois nÃºmeros. Utilize o somador de 8 bits projetado no item (9) em conjunto com portas lÃ³gicas adicionais, utilizando a abordagem por hierarquia.

## ResoluÃ§Ã£o

## DescriÃ§Ã£o em *systemverilog*

# Problema 11
Um circuito multiplicador de dois nÃºmeros de 8 bits, utilizando abordagem por fluxo de dados e
operadores aritmÃ©ticos.

## ResoluÃ§Ã£o

## DescriÃ§Ã£o em *systemverilog*

# Problema 12
Uma unidade lÃ³gico-aritmÃ©tica com a seguinte tabela de operaÃ§Ã£o utilizando a abordagem que desejar:

~~~
module neoalu(
    //bits do opcode
    input logic opc2, opc1, opc0,
    //entrada 8 bits de a
    input logic [3:0] a,
    //entrada 8 bits de b  
    input logic [3:0] b,
    //saÃ­da 8 bits da alu
    output logic [3:0] s,
    output logic a1,
    output logic b1,
    output logic c,
    output logic d,
    output logic e,
    output logic f,
    output logic g

);
    assign s0 = s[0];
    assign s1 = s[1];
    assign s2 = s[2];
    assign s3 = s[3];

always @(*) begin
     a1 = (~s3 & ~s2 & ~s1 & s0) | (~s3 & s2 & ~s1 & ~s0) | (s3 & s2 & ~s1 & s0) | (s3 & ~s2 & s1 & s0);
     b1 = (~s0 & ((s3 & s2)|(s2 & s1)))|(s0 & ((~s3 & s2 & ~s1)|(s3 & s1)));
     c = (~s3 & ~s2 & s1 & ~s0)|((s3 & s2) & (~s0|s1));
     d = (~s3 & ~s2 & ~s1 & s0)|(~s3 & s2 & ~s1 & ~s0)|(s2 & s1 & s0)|(s3 & ~s2 & s1 & ~s0);
     e = (s0 & (~s3|(~s2 & ~s1)))|(~s3 & s2 & ~s1);
     f = ((~s3 & ~s2) & (s0|s1))|(~s3 & s1 & s0)|(s3 & s2 & ~s1 & s0);
     g = (~s3 & ~s2 & ~s1)|(~s3 & s2 & s1 & s0)|(s3 & s2 & ~s1 & ~s0);

    case ({opc2,opc1, opc0}) //concatenei aqui pra formar uma sÃ©rie de 3 bits
        // cada operaÃ§Ã£o relacionada Ã  cada opcode serÃ¡ descrita aqui
        // aplicando uma abordagem por fluxo de dados
        3'b000: s = a | b; // a or b -> opcode = 000
        3'b001: s = a & b; // a and b -> opcode = 001
        3'b010: s = a ^ b; // a xor b -> opcode = 010
        3'b011: s = ~a; // ~a -> opcode = 011
        3'b100: s = a + b; // a + b -> opcode = 100
        3'b101: s = a - b; // a - b -> opcode = 101
        3'b110: s = a + 1; // a + 1 -> opcode = 110
        3'b111: s = -a; // -a (comp de 2) -> opcode = 111
        // caso padrÃ£o (default): recebe um valor de 8 bit indefido e diferente do opcode. Ou seja, caso padrÃ£o = fora do escopo do opcode = erro
        default: s = 8'bx; // resultado invÃ¡lido
    endcase
end
endmodule
~~~

![P12OPC](/Problema%2012/Problema%2012%20-%20Assets/opcode.jpg)

Sendo ğ´ e ğµ dois nÃºmeros de 8 bits.

## ResoluÃ§Ã£o

## DescriÃ§Ã£o em *systemverilog*
